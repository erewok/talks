<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

# Servant in 5 Minutes 
## (plus 1 minute for Haskell...)

Erik Aker

[github.com/erewok/talks](https://github.com/erewok/talks)

---

## Servant: A library (or DSL) for *Describing* APIs

Library: [github.com/haskell-servant/servant](https://github.com/haskell-servant/servant)

Paper: http://alpmestan.com/servant/servant-wgp.pdf


> "By turning the API into a Haskell type and thereby into a first-class citizen of the language, we gain the ability to perform many operations on the API, while statically checking that all our applications are in fact conforming to the desired API and consistent with each other."

---

## Extremely Unsatisfactory Haskell Primer
### (a detour)

```haskell
someInt :: Int
someInt = 5

type MyInt = Int

-- This function works with type `MyInt` *and* `Int`
someFunc :: Int -> Bool
someFunc n = n > someInt

fibs :: Integer -> Integer
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

quicksort :: Ord a => [a] -> [a]
quicksort [] = []
quicksort (p:xs) = (quicksort lesser) ++ [p] ++ (quicksort greater)
    where
        lesser = filter (< p) xs
        greater = filter (>= p) xs
```

---

## Working with Servant: Core Ideas

1. "Describe" an API as a type, and 
1. Build (or generate) interpretations of it.

---

## What does "describing web APIs as a type" look like?

```haskell
{-# LANGUAGE DeriveGeneric, StandaloneDeriving, DeriveAnyClass #-}

module Lib where

import Servant

instance ToJSON Counter
instance FromJSON Counter

-- A sample thing to accept and/or return
newtype Counter = Counter { value :: Int }
  deriving (Generic, Show, Num)

type CounterHome = "counter-html" :> Get '[JSON, HTML] Counter
```

---

## We can also combine APIs

```haskell

type CounterHome = "counter-html" :> Get '[JSON, HTML] Counter

--| Example "mult": curl -XPost http://someurl/counter-multiplier/4

type CounterApi = "counter-post" :> Post '[JSON] Counter 
    :<|> "counter-multiplier" 
         :> Capture "mult" Int
         :> Post '[JSON] Counter
    :<|> "counter-reset-post"
         :> ReqBody '[JSON] Counter
         :> Post '[JSON] Counter

type SampleApi = CounterHome :<|> CounterApi

```

---

## Interpretation I: Serving Servant

```haskell
-- Our Server
server :: TVar Counter -> Server CounterApi
server counter = counterHome counter
  :<|> currentValue counter
  :<|> counterMult counter
  :<|> counterReset counter
  :<|> counterWithParam counter

-- Here's the *value* representation of our CounterApi type
counterApi :: Proxy CounterApi
counterApi = Proxy

main :: IO ()
main = do
  cntr <- newTVarIO 0  -- Create counter; start at 0
  Warp.run 8000 (serve counterApi $ server cntr)
```

---

## Server Handler example: JSON POST

```haskell
type CounterApi = "counter-reset-post"
        :> ReqBody '[JSON] Counter :> Post '[JSON] Counter
    ...

-- Our Server
server :: TVar Counter -> Server SampleApi
server counter = counterReset counter
  ...

counterReset :: MonadIO m => TVar Counter -> Counter -> m Counter
counterReset oldCounter newCounter = liftIO . atomically $ do
  writeTVar oldCounter newCounter
  pure newCounter
```

---

## Interpretation II: Generating Client code (Haskell, Javascript, Python...)

```haskell
module Main where

import Network.HTTP.Client (newManager, defaultManagerSettings)
import Servant.Client

import Lib

-- Haskell client generation
postCounter
  :<|> multiplier
  :<|> reset
  :<|> paramCounter = client counterApi
```

---

## Let's Make some HTTP Requests

The `client` function creates a bunch of client functions for each endpoint in our API.
You can't make *incorrectly-typed* requests with these client functions.

```haskell
queries :: ClientM (Counter, Counter, Counter)
queries = do
  initial <- reset $ Counter 10
  multCount <- multiplier 5
  post <- postCounter
  reset2 <- reset $ Counter 20
  multCount2 <- multiplier 5
  return (initial, multCount, post, reset2, multCount2)

run :: IO ()
run = do
  manager <- newManager defaultManagerSettings
  res <- runClientM queries (ClientEnv manager (BaseUrl Http "localhost" 8000 ""))
  case res of
    Left err -> putStrLn $ "Error: " ++ show err
    Right (initial, multCount, post, reset2, multCount2) -> do
      print initial
      print multCount
      print post
      print reset2
      print multCount2
```

---

## In action...

```
‚ùØ stack exec servant-sample-client
Counter {value = 10}
Counter {value = 50}
Counter {value = 50}
Counter {value = 20}
Counter {value = 100}
```

---

## We can also use servant-foreign to write client generators for any language

```haskell
instance HasForeignType Python B.ByteString Counter where
  typeFor _ _ _ = "{\"value\": int}"

main :: IO ()
main = do
  -- test out the Haskell clients
  run
  -- Write out a Python module with client code
  writePythonForAPI counterApi requests ("examples" </> "api.py")
```

---

## Other Interpretations

- Documentation: Generate Swagger, Markdown, etc.
- Clients in Javascript (Angular, jQuery, React, etc.) and other languages.
- Servant Quickcheck: quickcheck that two APIs are equal or no 500s!
- Generating Servant API types *from* Swagger Definitions: OpenAPI, Swagger CodeGen, 
- Whatever else people dream up.

---

## Thanks for listening!

Erik Aker

@erewok

github.com/erewok

</textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>